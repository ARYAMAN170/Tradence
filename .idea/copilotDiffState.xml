<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/main.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/main.py" />
              <option name="originalContent" value="from fastapi import FastAPI, HTTPException&#10;from pydantic import BaseModel&#10;from typing import Dict, Any, List, Optional&#10;import uuid&#10;&#10;from app.workflows.code_review import create_code_review_graph&#10;&#10;app = FastAPI(title=&quot;AI Workflow Engine&quot;)&#10;&#10;# --- In-Memory Storage ---&#10;graphs = {}  # Stores graph definitions (if you allowed dynamic creation)&#10;runs = {}  # Stores execution results: {run_id: {&quot;status&quot;: &quot;completed&quot;, &quot;result&quot;: ...}}&#10;&#10;&#10;# --- Models ---&#10;class CreateGraphRequest(BaseModel):&#10;    nodes: List[str]&#10;    edges: Dict[str, str]&#10;&#10;&#10;class RunGraphRequest(BaseModel):&#10;    # For this assignment, we mostly run the pre-defined Code Review graph&#10;    # But we can allow selecting a graph_id if we were fully dynamic&#10;    initial_state: Dict[str, Any]&#10;&#10;&#10;# --- Endpoints ---&#10;&#10;@app.post(&quot;/graph/create&quot;)&#10;async def create_graph(request: CreateGraphRequest):&#10;    &quot;&quot;&quot;&#10;    (Simplified) In a real dynamic system, you would parse the nodes/edges&#10;    and build a graph object dynamically.&#10;    For this assignment, we can just acknowledge the request or&#10;    register a simple config.&#10;    &quot;&quot;&quot;&#10;    graph_id = str(uuid.uuid4())&#10;    graphs[graph_id] = request.dict()&#10;    return {&quot;graph_id&quot;: graph_id, &quot;message&quot;: &quot;Graph structure saved (mock logic for dynamic graphs)&quot;}&#10;&#10;&#10;@app.post(&quot;/graph/run&quot;)&#10;async def run_workflow(request: RunGraphRequest):&#10;    &quot;&quot;&quot;&#10;    Runs the pre-defined 'Code Review' workflow (Option A)&#10;    to demonstrate the engine capabilities.&#10;    &quot;&quot;&quot;&#10;    run_id = str(uuid.uuid4())&#10;&#10;    # Initialize the specific workflow&#10;    workflow = create_code_review_graph()&#10;&#10;    # Execute (Async)&#10;    try:&#10;        result = await workflow.run(request.initial_state)&#10;&#10;        # Store result&#10;        runs[run_id] = {&#10;            &quot;status&quot;: &quot;completed&quot;,&#10;            &quot;final_state&quot;: result[&quot;final_state&quot;],&#10;            &quot;logs&quot;: result[&quot;logs&quot;]&#10;        }&#10;&#10;        return {&#10;            &quot;run_id&quot;: run_id,&#10;            &quot;status&quot;: &quot;completed&quot;,&#10;            &quot;result&quot;: result&#10;        }&#10;    except Exception as e:&#10;        runs[run_id] = {&quot;status&quot;: &quot;failed&quot;, &quot;error&quot;: str(e)}&#10;        raise HTTPException(status_code=500, detail=str(e))&#10;&#10;&#10;@app.get(&quot;/graph/state/{run_id}&quot;)&#10;async def get_run_state(run_id: str):&#10;    if run_id not in runs:&#10;        raise HTTPException(status_code=404, detail=&quot;Run ID not found&quot;)&#10;    return runs[run_id]" />
              <option name="updatedContent" value="from fastapi import FastAPI, HTTPException&#10;from pydantic import BaseModel&#10;from typing import Dict, Any, List, Optional&#10;import uuid&#10;&#10;from app.workflows.code_review import create_code_review_graph&#10;&#10;app = FastAPI(title=&quot;AI Workflow Engine&quot;)&#10;&#10;# --- In-Memory Storage ---&#10;graphs = {}  # Stores graph definitions (if you allowed dynamic creation)&#10;runs = {}  # Stores execution results: {run_id: {&quot;status&quot;: &quot;completed&quot;, &quot;result&quot;: ...}}&#10;&#10;&#10;# --- Models ---&#10;class CreateGraphRequest(BaseModel):&#10;    nodes: List[str]&#10;    edges: Dict[str, str]&#10;&#10;&#10;class RunGraphRequest(BaseModel):&#10;    # For this assignment, we mostly run the pre-defined Code Review graph&#10;    # But we can allow selecting a graph_id if we were fully dynamic&#10;    initial_state: Dict[str, Any]&#10;&#10;&#10;# --- Endpoints ---&#10;&#10;@app.post(&quot;/graph/create&quot;)&#10;async def create_graph(request: CreateGraphRequest):&#10;    &quot;&quot;&quot;&#10;    (Simplified) In a real dynamic system, you would parse the nodes/edges&#10;    and build a graph object dynamically.&#10;    For this assignment, we can just acknowledge the request or&#10;    register a simple config.&#10;    &quot;&quot;&quot;&#10;    graph_id = str(uuid.uuid4())&#10;    graphs[graph_id] = request.model_dump()&#10;    return {&quot;graph_id&quot;: graph_id, &quot;message&quot;: &quot;Graph structure saved (mock logic for dynamic graphs)&quot;}&#10;&#10;&#10;@app.post(&quot;/graph/run&quot;)&#10;async def run_workflow(request: RunGraphRequest):&#10;    &quot;&quot;&quot;&#10;    Runs the pre-defined 'Code Review' workflow (Option A)&#10;    to demonstrate the engine capabilities.&#10;    &quot;&quot;&quot;&#10;    run_id = str(uuid.uuid4())&#10;&#10;    # Initialize the specific workflow&#10;    workflow = create_code_review_graph()&#10;&#10;    # Execute (Async)&#10;    try:&#10;        result = await workflow.run(request.initial_state)&#10;&#10;        # Store result&#10;        runs[run_id] = {&#10;            &quot;status&quot;: &quot;completed&quot;,&#10;            &quot;final_state&quot;: result[&quot;final_state&quot;],&#10;            &quot;logs&quot;: result[&quot;logs&quot;]&#10;        }&#10;&#10;        return {&#10;            &quot;run_id&quot;: run_id,&#10;            &quot;status&quot;: &quot;completed&quot;,&#10;            &quot;result&quot;: result&#10;        }&#10;    except Exception as e:&#10;        runs[run_id] = {&quot;status&quot;: &quot;failed&quot;, &quot;error&quot;: str(e)}&#10;        raise HTTPException(status_code=500, detail=str(e))&#10;&#10;&#10;@app.get(&quot;/graph/state/{run_id}&quot;)&#10;async def get_run_state(run_id: str):&#10;    if run_id not in runs:&#10;        raise HTTPException(status_code=404, detail=&quot;Run ID not found&quot;)&#10;    return runs[run_id]" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>